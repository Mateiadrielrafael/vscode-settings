[["%",{"text":"Main.purs","registerMode":0}],["*",{"text":"-- TODO: getting the tokens here is kinda hacky, fix pls","registerMode":2}],["-",{"text":"(","registerMode":1}],["1",{"text":"-- TODO: getting the tokens here is kinda hacky, fix pls","registerMode":2}],["2",{"text":"  for_ (ZipperArray.fromArray tokens) \\tokens' -> do","registerMode":2}],["3",{"text":"    -- logShow plus'\n    -- case runCheckM { types, values } m of\n    --   Right v -> logShow v\n    --   Left e -> error $ show e","registerMode":2}],["4",{"text":"  where -- This is some very messy code I use for debugging","registerMode":2}],["5",{"text":"  go :: List TopLevelEntry -> Effect Unit\n  go = go' mempty\n\n  go' :: { types :: Map.Map Name Value, values :: Map.Map Name Value } -> List TopLevelEntry -> Effect Unit\n  go' _ Nil = pure unit\n\n  go' past ((Declaration name ast) : tail) = do\n    let\n      term = toTerm' ast\n\n      m = do\n        type' <- infer term\n        value <- eval term\n        quoted <- quote' value\n        pure { value, type', quoted }\n    case runCheckM (mkEnv past) m of\n      Left err -> do\n        log $ errorText $ \"Type error (\" <> withGraphics italic name <> \"):\"\n        logShow err\n      Right { type', value, quoted } -> do\n        when (List.null tail) $ logShow $ Annotation quoted (valueToTerm type')\n        let\n          past' =\n            past\n              { values = Map.insert (Global name) value past.values\n              , types = Map.insert (Global name) type' past.types\n              }\n        go' past' tail\n\n  go' past ((Axiom name ast) : tail) = do\n    let\n      type' = runEvalM { global: past.values, local: mempty } $ eval $ toTerm' ast\n    go' (past { types = Map.insert (Global name) type' past.types }) tail\n\n  toTerm' :: Ast -> Term\n  toTerm' value = runAstM mempty $ toTerm value\n\n  mkEnv past = { types: mkCtx past.types, values: mkCtx past.values }\n    where\n    mkCtx global = { global, local: mempty }","registerMode":2}],["6",{"text":"","registerMode":2}],["7",{"text":"import ErrorStack (throw)","registerMode":2}],["8",{"text":"","registerMode":2}],["9",{"text":"import ErrorStack (throw)","registerMode":2}],["0",{"text":"first :: (a : *) -> (b : *) -> Tuple a b -> a\nfirst = \\A B T => T A \\a b => a","registerMode":2}],["/",{"text":"_.local","registerMode":0}]]